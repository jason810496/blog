[{"content":"","date":"2024-06-09","externalUrl":null,"permalink":"/zh-tw/tags/blog/","section":"標籤","summary":"","title":"Blog","type":"tags"},{"content":"","date":"2024-06-09","externalUrl":null,"permalink":"/zh-tw/tags/database/","section":"標籤","summary":"","title":"Database","type":"tags"},{"content":" 前情提要 # Django 雖然可以設定 CONNECTION_MAX_AGE 之類的 config 但是對於使用 gunicorn ( muti-process ) 跑起多個 API instance 或是在 k8s 用 HPA 擴展 API instance 時 還是會出現 DB 過多 connection 的問題！\n關於 PgBouncer # pgbouncer/pgbouncer lightweight connection pooler for PostgreSQL C 2724 429 PgBouncer : 可以當作集中的 DB Connection Pool 的中間件\n讓各個後端服務 instance 透過 PgBouncer 重複利用 DB connection\n如圖所示：\n在右側的 Transactions per second 可以看到 3 次 load testing 飆高的 transactions 數量 而 第 2 次 的 load testing 是 使用 Django 原生的 DB 連接方式 第 1 、 3 次 是使用 pgbouncer 作為 WebService instance 的連接對象 可以觀察到左側 Server sessions ( 也可以視為當前的 DB connection 數量 ) 可以看到 第 2 次 的 load testing：有出現 DB 過多 connection 的問題！ 而 第 1 、 3 次 的 load testing : DB connection 穩定的維持在 20 幾 後端服務 Config # 需要特別設定的地方：\ndocker-compose.yml .env docker-compose.yml db 和 pgbouncer 要 掛在同一個 network 因為是從 Docker 的 internal network 所以對於 pgbouncer 的 postgres HOST 需要填 db db: image: postgres:15.1 container_name: postgres restart: always environment: POSTGRES_USER: your_postgres_user POSTGRES_PASSWORD: your_postgres_password POSTGRES_DB: dev ports: - 5432:5432 volumes: - pg_data:/var/lib/postgresql/data networks: - django_network pgbouncer: image: bitnami/pgbouncer container_name: pgbouncer restart: always ports: - 6432:6432 # 如果要連 `pgbouncer` 需要連 6432 port environment: POSTGRESQL_USERNAME: your_postgres_user POSTGRESQL_PASSWORD: your_postgres_password POSTGRESQL_HOST: db POSTGRESQL_PORT: 5432 POSTGRESQL_DATABASE: dev PGBOUNCER_DATABASE: dev networks: - django_network # 讓 `db` 和 `pgbouncer` 在同一個 network .env 如果要連 pgbouncer 需要把 DB_BOUNCER=True 並且 DB_PORT=6432 # if you want to use postgres you should set DB_ENGINE DB_ENGINE=django.db.backends.postgresql DB_HOST=127.0.0.1 # DB_PORT=5432 DB_NAME=postgres DB_USER=USER_NAME DB_PASSWORD=PASSWORD12345678 # if you want to use `pgbouncer` you should set DB_BOUNCER=True # and set DB_PORT to 6432 DB_BOUNCER=True DB_PORT=6432 後端服務 setting.py 修改 # 有更改到的細節：\n這邊使用 pydantic 的 BaseSettings 來設定 DB 的 config 並且在 settings.py 中，根據 DB_BOUNCER 來決定要連接 DB 或是 pgbouncer config.py\nfrom pydantic import BaseSettings,Field class DATABASE_SETTINGS(BaseSettings): model_config = SettingsConfigDict(env_prefix=\u0026#39;DB_\u0026#39;) ENGINE: str = Field(default=\u0026#39;django.db.backends.sqlite3\u0026#39;) HOST: str = Field(default=\u0026#39;\u0026#39;) PORT: int = Field(default=\u0026#39;\u0026#39;) NAME: str = Field(default=\u0026#39;\u0026#39;) USER: str = Field(default=\u0026#39;\u0026#39;) PASSWORD: str = Field(default=\u0026#39;\u0026#39;) CONN_MAX_AGE: int = Field(default=1) CONN_HEALTH_CHECKS: bool = Field(default=True) BOUNCER: bool = Field(default=False) database_settings = DATABASE_SETTINGS() settings.py\nfrom config import database_settings DATABASES = { \u0026#39;default\u0026#39;: database_settings.model_dump(mode=\u0026#34;json\u0026#34;) } if database_settings.BOUNCER: DATABASES[\u0026#39;default\u0026#39;][\u0026#39;DISABLE_SERVER_SIDE_CURSORS\u0026#39;] = True Reference # https://saadmk11.github.io/blog/posts/django-postgresql-database-connection-pooling-with-pgbouncer/ https://stackoverflow.com/questions/76046768/configure-pgbouncer-and-postgresql-in-docker-compose https://hub.docker.com/r/bitnami/pgbouncer/ https://www.pgbouncer.org/config.html ","date":"2024-06-09","externalUrl":null,"permalink":"/zh-tw/database/pgbouncer/","section":"資料庫 首頁","summary":"以 PgBouncer 解決 Django 後端 DB connection 過多的問題","title":"PgBouncer: 輕量 Postgres 連接池","type":"database"},{"content":"","date":"2024-06-09","externalUrl":null,"permalink":"/zh-tw/tags/zh-tw/","section":"標籤","summary":"","title":"Zh-Tw","type":"tags"},{"content":"","date":"2024-06-09","externalUrl":null,"permalink":"/zh-tw/tags/","section":"標籤","summary":"","title":"標籤","type":"tags"},{"content":"","date":"2024-06-09","externalUrl":null,"permalink":"/tags/en/","section":"tags","summary":"","title":"En","type":"tags"},{"content":" 前言 # 目前擔任程式設計（一）助教 因為實習課教室電腦的 IP 都是內網 IP 然後系上 Online Judge 的 VM 只給學校 IP ( 140.116.xxx.xxx ) 進來 沒有開放內網 IP 進來 原本用 ngrok 來做 NAT 但是 ngrok 的免費版每個 tunnel 只給 40 人用 修課人數有 240 多個人 不太可能開 6 個 tunnel 再分配學生連線\n這樣非常麻煩\u0026hellip; 而且每次 ngrok 重啟都會換一個新的 domain 這樣學生要重新設定連線的 domain ngrok 的替代方案 # Cloudflare Tunnel Cloudflare Tunnel Free Plan 的 : dns setup no connection limitation ( name server 要在 Cloudflare 上 ) 其他與 ngrok 一樣 cloudflare tunnel 文件 # https://developers.cloudflare.com/pages/how-to/preview-with-cloudflare-tunnel/\nInstalltion # 可以到 Cloudflare Tunnel Downloads找適合自己的 OS 的版本 Mac OS :\nbrew install cloudflare/cloudflare/cloudflared Linux :\nwget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb sudo apt install ./cloudflared-linux-amd64.deb Normal Usage # 如果是 ngrok :\nngrok http 8888 如果是 cloudflare tunnel :\ncloudflared tunnel --url http://localhost:8888 就可以從隨機生成 URL 連線到 localhost:8888 了 但是如果要自己設定 domain 的話，就要額外設定 cloudflared 的 config file Advanced Usage # 在設定 domain 前，要確認 domain 的 Nameserver 是設定在 Cloudflare 上 設定完後：可以從自己的 DNS 連到 server 的 localhost:\u0026lt;port\u0026gt;\n接著可以使用 command line 來設定 cloudflared 的 config file Authentication cloudflared tunnel login Create a Tunnel cloudflared create \u0026lt;tunnel_name\u0026gt; cloudflared tunnel route dns \u0026lt;tunnel_name\u0026gt; \u0026lt;domain_name\u0026gt; 會在 ~/.cloudflared/ 產生一個 \u0026lt;tunnel_id\u0026gt;.json 可以在 cloudflare dashboard 中 Access 的 tunnel 看到 \u0026lt;tunnel_id\u0026gt; 在 DNS 的 records 看到加上的 \u0026lt;domain_name\u0026gt; content 的部分是 \u0026lt;tunnel_id\u0026gt;.cfargotunnel.com configuation # cloudflare tunnel : setup configuration file\n接著在 ~/.cloudflared/ 中加上 config.yaml tunnel: \u0026lt;tunnel-id\u0026gt; credentials-file: /path/to/\u0026lt;tunnel-id\u0026gt;.json # 之前產生的 json file 在 ~/.cloudflared/ 中 ingress: - hostname: \u0026lt;domain-name\u0026gt; service: http://localhost:\u0026lt;port1\u0026gt; - service: http_status:404 在設定 config.yaml 的時候，可以設定多個 ingress 這樣就可以把不同的 port 對應到不同的 domain 例如 :\nlocalhost:8888 對應到 service1.domain.com localhost:9999 對應到 service2.domain.com Start Tunnel # 啟動 tunnel :\ncloudflared tunnel run \u0026lt;tunnel_name\u0026gt; 可以透過 tmux 讓 tunnel 在背景執行 可以參考 tmux 常用指令 !\n使用 tmux :\ntmux new -s cloudflare-tunnel 然後在 tmux 中執行 cloudflared tunnel run \u0026lt;tunnel_name\u0026gt; 按下 ctrl + b 再按 d 就可以離開 tmux 如果要回到 tmux 中的話，可以用 tmux attach -t cloudflare-tunnel Command list # cloudflared tunnel login cloudflared create \u0026lt;tunnel_name\u0026gt; cloudflared tunnel route dns \u0026lt;tunnel_name\u0026gt; \u0026lt;domain_name\u0026gt; 會在 ~/.cloudflared/ 產生一個 \u0026lt;tunnel_id\u0026gt;.json 並在這邊加上 config.yaml 在 cloudflare dashboard 中 Access 的 tunnel 可以看到 \u0026lt;tunnel_id\u0026gt;\ncloudflared tunnel run \u0026lt;tunnel_name\u0026gt; Reference # Cloudflare Tunnel : Overview Cloudflare Tunnel : Downloads Cloudflare Tunnel : Setup configuration file Cloudflare Tunnel : Ingress ","date":"2024-05-28","externalUrl":null,"permalink":"/zh-tw/note/cloudflare-tunnel/","section":"Note","summary":"設定 Cloudflare Tunnel 來穿透內網 IP，Ngrok 的替代方案","title":"Cloudflare Tunnel","type":"note"},{"content":" tmux/tmux tmux source code C 33479 2049 前言 # 因為系上開給程式設計一的 VM 需要設定 cloudflare tunnel 才能連線 ( 有興趣可以看 我的 cloudflare-tunnel 設定過程 ) 所以想用 tmux 來讓 tunnel 一直在背景執行 也可以隨時查看 tunnel 的狀態 tmux 概念 # tmux 可以分成三個層級 Session Window Pane Session # Session 是 tmux 的最高層級 可以想像成一個 tmux 的工作區 一個 Session 可以有多個 Window ( 列出所有可用的 session )\nWindow # Window 是 tmux 的第二層 可以想像成一個 Session 中的不同視窗 一個 Window 可以有多個 Pane Pane # Pane 是 tmux 的第三層 可以想像成一個 Window 中的不同分割畫面 一個 Pane 只能有一個 Shell 同一個 Window 中的 Pane 可以被水平或垂直分割 ( 所以可以被切成這樣 )\ntmux 常用指令 # 如果是在 tmux 中，可以直接按 Ctrl + b 來進入 tmux 的指令模式 ( 像是在 vim 中按 : 一樣 ) Session # 從 command line : tmux new -s \u0026lt;session-name\u0026gt; : 新增一個名為 \u0026lt;session-name\u0026gt; 的 session tmux ls : 列出所有可用的 session tmux attach -t \u0026lt;session-name\u0026gt; : 連接到名為 \u0026lt;session-name\u0026gt; 的 session 在 tmux 中 : Ctrl + b + d : 離開 tmux session 並不會把 session 關掉，只是離開而已 所以在 session 中的程式還是會繼續執行 !!! Ctrl + b + s : 列出所有可用的 session Window # Ctrl + b + c : 新增一個 window Ctrl + b + n : 切換到下一個 window Ctrl + b + p : 切換到上一個 window Ctrl + b + w : 列出所有可用的 window Pane # pane 分割:\nCtrl + b + % : 垂直分割畫面 ( 左右分割 ) Ctrl + b + \u0026quot; : 水平分割畫面 ( 上下分割 ) Ctrl + b + x : 關閉目前的 pane 調整 pane 的大小: 可以先按 Ctrl + b 再按 : 進入 tmux 的指令模式 然後輸入 resize-pane ( 可以按 Tab 來自動補全 ) 再加上 -U ( 上 ) -D ( 下 ) -L ( 左 ) -R ( 右 ) 再加上數字來調整 pane 的大小 在 pane 之間切換:\nCtrl + b + \u0026lt;arrow-key\u0026gt; : 切換到指定的 pane Ctrl + b + q : 會在 pane 上顯示一個數字 Ctrl + b + q + \u0026lt;number\u0026gt; : 切換到指定的 pane ","date":"2024-05-28","externalUrl":null,"permalink":"/zh-tw/note/tmux/","section":"Note","summary":"常用 tmux 指令 Cheat Sheet","title":"常用 tmux 指令","type":"note"},{"content":"","date":"2024-05-28","externalUrl":null,"permalink":"/zh-tw/tags/aws/","section":"標籤","summary":"","title":"AWS","type":"tags"},{"content":"","date":"2024-05-28","externalUrl":null,"permalink":"/zh-tw/tags/backend/","section":"標籤","summary":"","title":"Backend","type":"tags"},{"content":"","date":"2024-05-28","externalUrl":null,"permalink":"/zh-tw/tags/fastapi/","section":"標籤","summary":"","title":"FastAPI","type":"tags"},{"content":" 介紹 # 在 FastAPI 框架中使用 moto 模擬 boto3。 boto3 : AWS 的 Python SDK moto : 用於模擬 AWS 的 Python SDK 的 Package server mode 用於模擬 AWS 服務 mock_aws decorator 用於模擬 AWS 操作 FastAPI 提供 TestClient : 參考 與 pytest 一起進行測試 應用範例 # 在 FastAPI 中，常見模式是使用 Depends 進行依賴注入\n順便說一下，Depends 可以是遞迴的 這表示，A Depends 可以依賴於 B Depends 和 C Depends\n範例: endpoint.py\nfrom fastapi import Depends @FileV1Router.post( path=\u0026#34;/files\u0026#34;, response_model=v1_schemas.FilePresignedUrlResponse, ) async def create_file_endpoint( file: v1_schemas.FileCreate, file_service: FileService = Depends(get_file_service), user_id: str = Depends(get_current_user), ): file_response = file_service.generate_presigned_upload_url(file, user_id) return file_response deps.py\ndef get_file_service( # sqlalchemy `Session` 實例 db: Session = Depends(get_db), # `boto3.client(\u0026#39;s3\u0026#39;)` 實例 s3_client=Depends(get_s3_client), ): # 使用 依賴注入 `FileService` 實例 return FileService( db, s3_client, ) 使用 Database 範例的 dependency_overrides # 在測試時，我們可能想要覆蓋 get_db 依賴 使用我們的測試資料庫，如內存中的 sqlite。\n幸運的是，FastAPI 提供了 FastAPI: Override Testing Dependencies 的工具！\n繼續前面的程式。\ndef override_get_db(): try: # 使用 mock DB 的 sqlalchemy `sessionmaker` db = TestingSessionLocal() yield db finally: db.close() # app : 來自主應用程式的原始 FastAPI 實例 app.dependency_overrides[get_db] = override_get_db testClient = TestClient(app) 設置 moto # moto : 一個模擬基於 AWS 基礎設施測試的 package 。\nMoto: Server Mode # Moto: Server Mode\nMoto 也提供獨立的 Server Mode。（用於模擬 AWS 服務） 我建議使用 Docker 設置 moto-server\ndocker run --rm -p 5000:5000 --name moto motoserver/moto:latest 或使用 Docker-Compose 如果有其他基礎設施依賴。\nversion: \u0026#39;3.7\u0026#39; services: moto: image: motoserver/moto:4.1.13 ports: - \u0026#34;5000:5000\u0026#34; environment: - MOTO_PORT=5000 docker compose up moto -d 儀表板 Moto 伺服器提供一個儀表板，用於監控當前服務狀態。\nhttp://localhost:5000/moto-api/ 推薦用法與範例（來自官方文檔） # 推薦用法\n確保在測試範圍內設置虛擬環境。\nos.environ[\u0026#34;AWS_ACCESS_KEY_ID\u0026#34;] = \u0026#34;testing\u0026#34; os.environ[\u0026#34;AWS_SECRET_ACCESS_KEY\u0026#34;] = \u0026#34;testing\u0026#34; os.environ[\u0026#34;AWS_SECURITY_TOKEN\u0026#34;] = \u0026#34;testing\u0026#34; os.environ[\u0026#34;AWS_SESSION_TOKEN\u0026#34;] = \u0026#34;testing\u0026#34; os.environ[\u0026#34;AWS_DEFAULT_REGION\u0026#34;] = \u0026#34;us-east-1\u0026#34; os.environ[\u0026#34;MOTO_S3_CUSTOM_ENDPOINTS\u0026#34;] = \u0026#34;http://127.0.0.1:3000\u0026#34; 使用 Pytest 的範例\n@pytest.fixture(scope=\u0026#34;function\u0026#34;) def aws_credentials(): \u0026#34;\u0026#34;\u0026#34;Moto 的模擬 AWS 憑證。\u0026#34;\u0026#34;\u0026#34; os.environ[\u0026#34;AWS_ACCESS_KEY_ID\u0026#34;] = \u0026#34;testing\u0026#34; os.environ[\u0026#34;AWS_SECRET_ACCESS_KEY\u0026#34;] = \u0026#34;testing\u0026#34; os.environ[\u0026#34;AWS_SECURITY_TOKEN\u0026#34;] = \u0026#34;testing\u0026#34; os.environ[\u0026#34;AWS_SESSION_TOKEN\u0026#34;] = \u0026#34;testing\u0026#34; os.environ[\u0026#34;AWS_DEFAULT_REGION\u0026#34;] = \u0026#34;us-east-1\u0026#34; @pytest.fixture(scope=\u0026#34;function\u0026#34;) def aws(aws_credentials): with mock_aws(): yield boto3.client(\u0026#34;s3\u0026#34;, region_name=\u0026#34;us-east-1\u0026#34;) @pytest.fixture def create_bucket1(aws): boto3.client(\u0026#34;s3\u0026#34;).create_bucket(Bucket=\u0026#34;b1\u0026#34;) @pytest.fixture def create_bucket2(aws): boto3.client(\u0026#34;s3\u0026#34;).create_bucket(Bucket=\u0026#34;b2\u0026#34;) def test_s3_directly(aws): s3.create_bucket(Bucket=\u0026#34;somebucket\u0026#34;) result = s3.list_buckets() assert len(result[\u0026#34;Buckets\u0026#34;]) == 1 def test_bucket_creation(create_bucket1, create_bucket2): buckets = boto3.client(\u0026#34;s3\u0026#34;).list_buckets()[\u0026#34;Buckets\u0026#34;] assert len(result[\u0026#34;Buckets\u0026#34;]) == 2 使用 dependency_overrides 覆蓋 s3_client 依賴 # 使用 moto 和 dependency_overrides 的基本用法 我們可以用 moto 模擬 S3 客戶端 override get_s3_client 依賴~\ndef override_get_s3_client(): os.environ[\u0026#34;AWS_ACCESS_KEY_ID\u0026#34;] = \u0026#34;testing\u0026#34; os.environ[\u0026#34;AWS_SECRET_ACCESS_KEY\u0026#34;] = \u0026#34;testing\u0026#34; os.environ[\u0026#34;AWS_SECURITY_TOKEN\u0026#34;] = \u0026#34;testing\u0026#34; os.environ[\u0026#34;AWS_SESSION_TOKEN\u0026#34;] = \u0026#34;testing\u0026#34; os.environ[\u0026#34;AWS_DEFAULT_REGION\u0026#34;] = \u0026#34;us-east-1\u0026#34; os.environ[\u0026#34;MOTO_S3_CUSTOM_ENDPOINTS\u0026#34;] = \u0026#34;http://127.0.0.1:3000\u0026#34; try: with mock_aws(): conn = boto3.resource(\u0026#34;s3\u0026#34;) conn.create_bucket(Bucket=file_settings.USER_BUCKET_NAME) s3_client = boto3.client( \u0026#34;s3\u0026#34;, region_name=\u0026#34;us-east-1\u0026#34;, endpoint_url=\u0026#34;http://127.0.0.1:3000\u0026#34; ) yield s3_client finally: pass # app : 來自主應用程式的原始 FastAPI 實例 app.dependency_overrides[get_s3_client] = override_get_s3_client testClient = TestClient(app) 並且，不要忘記為 pytest 函數添加 mock_aws\nfrom moto import mock_aws from test.client import testClient @mock_aws def test_create_file(test_user_setup_teardown): valid_user_data, response = test_user_setup_teardown response = testClient.post( \u0026#34;/files\u0026#34;, headers={ \u0026#34;Authorization\u0026#34;: \u0026#34;{token_type} {token}\u0026#34;.format( token_type=response.json()[\u0026#34;token_type\u0026#34;], token=response.json()[\u0026#34;access_token\u0026#34;], ) }, json={\u0026#34;filename\u0026#34;: \u0026#34;test-file\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is a test file\u0026#34;}, ) # ... ","date":"2024-05-28","externalUrl":null,"permalink":"/zh-tw/backend/k8s-fastapi-mock-boto3-s3-with-moto/","section":"後端首頁","summary":"FastAPI 測試: 使用 Moto 模擬 AWS S3 Boto3","title":"FastAPI: 使用 Moto 模擬 S3","type":"backend"},{"content":"","date":"2024-05-28","externalUrl":null,"permalink":"/zh-tw/tags/testing/","section":"標籤","summary":"","title":"Testing","type":"tags"},{"content":"","date":"2024-05-28","externalUrl":null,"permalink":"/zh-tw/tags/devops/","section":"標籤","summary":"","title":"Devops","type":"tags"},{"content":" Kubernetes Cheat Sheet: 提取 ConfigMap 或 Secret 到 .env 文件 # 從 ConfigMap 輸出 # kubectl get configmap my-map --output json | jq \u0026#39;.data\u0026#39; | jq -r \u0026#39;to_entries | map(.key + \u0026#34;=\u0026#34; + (.value)) | .[]\u0026#39; \u0026gt;\u0026gt; .env 說明:\nkubectl get configmap my-map --output json | # 取出 data 部分。 jq \u0026#39;.data\u0026#39; | # 將每個 \u0026#34;key\u0026#34;: \u0026#34;value\u0026#34; 對替換為 \u0026#34;key=value\u0026#34; jq -r \u0026#39;to_entries | map(.key + \u0026#34;=\u0026#34; + (.value)) | .[]\u0026#39; \u0026gt;\u0026gt; .env 從 Secret 輸出 # kubectl get secret my-secret --output json | jq \u0026#39;.data\u0026#39; | jq \u0026#39;map_values(@base64d)\u0026#39; | jq -r \u0026#39;to_entries | map(.key + \u0026#34;=\u0026#34; + (.value)) | .[]\u0026#39; \u0026gt;\u0026gt; .env 說明:\nkubectl get secret my-secret --output json | # 取出 data 部分。 jq \u0026#39;.data\u0026#39; | # base64 decode 每個鍵的值。 jq \u0026#39;map_values(@base64d)\u0026#39; | # 將每個 \u0026#34;key\u0026#34;: \u0026#34;value\u0026#34; 對替換為 \u0026#34;key=value\u0026#34; jq -r \u0026#39;to_entries | map(.key + \u0026#34;=\u0026#34; + (.value)) | .[]\u0026#39; \u0026gt;\u0026gt; .env 從 helm 輸出 # # 使用 `awk`：我們從包含 `configmap` 的 row 開始輸出，直到第一個空行。 awk \u0026#39;{if ($0 ~ /^configmap:$/) {triggered=1;}if (triggered) {print; if ($0 ~ /^$/) { exit;}}}\u0026#39; \u0026#34;./project/values.yaml\u0026#34; | # 只保留包含我們 config grep \u0026#39;^ \u0026#39; | # 將 key: value 轉換為 key=value sed \u0026#39;s/ //;s/: /=/\u0026#39; \u0026gt;\u0026gt; .env 參考 # https://www.jujens.eu/posts/en/2021/Mar/21/kubectl-cfg-to-env/ ","date":"2024-05-28","externalUrl":null,"permalink":"/zh-tw/devops/k8s-extract-configmap-or-secret-to-env-file/","section":"DevOps 首頁","summary":"Kubernetes Cheat Sheet: 將 ConfigMap 或 Secret 輸出至 .env 格式","title":"k8s: 將 ConfigMap 或 Secret 輸出至 .env 格式","type":"devops"},{"content":"","date":"2024-05-28","externalUrl":null,"permalink":"/zh-tw/tags/kubernetes/","section":"標籤","summary":"","title":"Kubernetes","type":"tags"},{"content":"","date":"2024-05-21","externalUrl":"/zh-tw/backend/","permalink":"/zh-tw/categories/backend/","section":"分類首頁","summary":"Backend 相關文章","title":"Backend","type":"categories"},{"content":"","date":"2024-05-21","externalUrl":"/zh-tw/note/","permalink":"/zh-tw/categories/note/","section":"分類首頁","summary":"筆記相關文章","title":"Note","type":"categories"},{"content":"","date":"2024-05-21","externalUrl":"/zh-tw/devops/","permalink":"/zh-tw/categories/devops/","section":"分類首頁","summary":"DevOps 相關文章","title":"DevOps","type":"categories"},{"content":"","date":"2024-05-21","externalUrl":"/zh-tw/database/","permalink":"/zh-tw/categories/database/","section":"分類首頁","summary":"Database 相關文章","title":"Database","type":"categories"},{"content":"","date":"2024-05-21","externalUrl":null,"permalink":"/zh-tw/note/","section":"Note","summary":"","title":"Note","type":"note"},{"content":"","date":"2024-05-21","externalUrl":null,"permalink":"/zh-tw/devops/","section":"DevOps 首頁","summary":"","title":"DevOps 首頁","type":"devops"},{"content":"","date":"2024-05-21","externalUrl":null,"permalink":"/zh-tw/backend/","section":"後端首頁","summary":"","title":"後端首頁","type":"backend"},{"content":"","date":"2024-05-21","externalUrl":null,"permalink":"/zh-tw/other/","section":"後端首頁","summary":"","title":"後端首頁","type":"other"},{"content":"","date":"2024-05-21","externalUrl":null,"permalink":"/zh-tw/sample/","section":"後端首頁","summary":"","title":"後端首頁","type":"sample"},{"content":"","date":"2024-05-21","externalUrl":null,"permalink":"/zh-tw/database/","section":"資料庫 首頁","summary":"","title":"資料庫 首頁","type":"database"},{"content":" 最近的文章 Backend \u0026#8599; \u0026#8598; 2024-05-21 Backend 相關文章 Note \u0026#8599; \u0026#8598; 2024-05-21 筆記相關文章 DevOps \u0026#8599; \u0026#8598; 2024-05-21 DevOps 相關文章 Database \u0026#8599; \u0026#8598; 2024-05-21 Database 相關文章 ","date":"2024-05-21","externalUrl":null,"permalink":"/zh-tw/categories/","section":"分類首頁","summary":"最近的文章 Backend \u0026#8599; \u0026#8598; 2024-05-21 Backend 相關文章 Note \u0026#8599; \u0026#8598; 2024-05-21 筆記相關文章 DevOps \u0026#8599; \u0026#8598; 2024-05-21 DevOps 相","title":"分類首頁","type":"categories"},{"content":"","date":"2024-05-21","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2024-05-21","externalUrl":null,"permalink":"/zh-tw/tags/new-article/","section":"標籤","summary":"","title":"New-Article","type":"tags"},{"content":"","date":"2024-05-21","externalUrl":null,"permalink":"/zh-tw/sample/test-article/","section":"後端首頁","summary":"","title":"Test Article","type":"sample"},{"content":"","date":"2024-05-21","externalUrl":null,"permalink":"/zh-tw/other/test-article/","section":"後端首頁","summary":"","title":"其他測試文章\"","type":"other"},{"content":"","date":"2024-05-18","externalUrl":null,"permalink":"/zh-tw/","section":"歡迎來到 Blowfish! 🎉","summary":"","title":"歡迎來到 Blowfish! 🎉","type":"page"},{"content":" 成大資工大一上紀錄 # 其實這篇文章是在大一升大二暑假寫的 主要是翻行事曆整理一下我到底大一上有做什麼 其實我大一上的重心並不是在學科 而是在接案、社團、偏實作的課程\n還有我真的有興趣的課程上 ( 模糊化的行事曆 )\n不過到期末發現好像接太多外務ㄌ 有點忙不過來，大概一週就有好幾個 Deadline 可能是因為高中後期對於學科疲乏 覺得學到的知識都無法運用在未來的場景 好像學這些沒什麼意義（？ 比較多都是為了當下的分數而硬背起來的 這也是我比較不想管學科的原因 大一上到底做了什麼 # 主要會以這幾個方向來分類：\n作業/接案 社團 比賽 籌辦HSPC 課程 作業/接案 # 因為不想花心力念一些只為了考試分數的學科 所以我就把時間花在作業和接案上 盡量多累積一些實作經驗 作業 # 其實在高三下我就有開始在接大學 DSA 相關的作業了 主要是當作練功，也順變賺點小外快 在上學期間接了不少個作業，主要也是寫 C++ 偶爾有一些特別的作業：\n用 Matlab 來實作一些演算法 寫 Scala 這個完全沒聽過的 functional programming language 寫 C 的 generic function 這種第一次接觸真的很難弄會的主題 或是超難的圖論題\n接案 # 剛好在成大二手版看到一個徵網頁工讀生的貼文 從高三上接觸前端，升大一暑假也有寫過一些後端 CRUD 對基本的前後端應該都有一些概念 就去應徵看看 （ 當時的招募貼文 ）\n案主是也是成大的大學長 網站原本是由外包公司完成的 後來由另一位學長在幫忙修改、新增功能 整個網站的 tech stack 是：\nHosting : Hostinger ( 我自己沒聽過，不過用起來延遲有時候有點嚴重 ) Frontend : jQuery raw HTML/CSS/JS Backend : PHP: Slim framework ( 那時候只知道 Laravel，沒聽過 Slim ) MySQL Structure : MVC Version Control : Git Self hosted Git server: Gitea CI/CD : null (?) 網頁的瀏覽人數不高，不過整體的網頁架構也蠻複雜的（ 有些 Code 不太好看，蠻難改的 ） 不過有蠻多 features 案主想要新增修改的 主要是跟保險有關的網站系統 Features ：\n網頁前台 保險計算 保險推薦 保險資訊 文章系統 網頁後台 會員系統管理 保險 CRUS 文章 CRUD 負責的任務：\n一些小 bug fix： 有些資料要先排序才再送到前端 找到相對應的 SQL query，加上 ORDER BY... 一些前端 RWD 跑版修正 需要一直跟案主來回確認版型 新增後台文章 wsywig 編輯器： wsywig 編輯器：類似 Google doc ，可以在網頁上直接編輯文章的段落、大小、顏色、加圖片\u0026hellip;的工具 原本的文章系統只有單純一個 textarea，沒有 wsywig 編輯器 後來用 quill.js 這個開源的 js library 實作 一開始找到付費的 froala ，當時沒有把文件看清楚，以為是可以免費試用的，後來才發現是付費的 很多前端的修正： 一些 RWD 的跑版 一些前端的 UI/UX 調整 一些前端的功能新增 遇到各種 js 的坑 因為沒有用現在前端 framework ，整個的前端頁面架構蠻亂的，有時候要找到對應的 css 很花時間 ( 把 wsywig 編輯器到後台文章系統 )\n遇到奇怪的事：\n肉眼 + SMTP = 專案的 CI/CD 🤯 : 把當前 feature 弄好後，在 local 跑起來再開 ngrok 給案主測 沒問題後把 code push 到 Gitea 上 那要怎麼部署到 Hostinger 呢？ 真的是體會過才會知道好的 CI/CD 有多重要 先把會更動到的檔案用 SMTP 備份下來 (方便之後有問題 rollback ) 再把有更新的檔案複製到 Hostinger 上 所以就很容易會有 Hostinger 上的 code 跟 Gitea 上的 code 不一樣的問題\u0026hellip; 在 backend 商業邏輯寫前端 : 雖然整體是 MVC 架構 不過會看到一個像後端的 php 檔案回傳一整個 component 的 html ，但沒有分離到 view (找了超久才知道要在哪裡改前端的某個 compoent ) 對 Github 的抗拒 : 不知道為什麼一開始學長和案主不想用 Github 反而大費周張自己架 git server 而且當時那個學長家裡的 WAN 並沒有申請固定 IP ，所以每次都要透過 ngrok 來連到 git server 也就是我跟學長必須要同時在現在才有辦法 push code ( 而且每次都需要加新的 remote ) 如果用 Github 就不會有這個問題，而且還可以用 Github 跑一些 CI/CD 的流程 這是算是我第一次接到的案子 這個案子我接了大概 3-4 個月 也是我第一次接觸到 CI/CD 的重要性 透過這個案子學到的：\n快速上手不熟悉的語言和框架 一些框架延伸的 design pattern MVC、DAO 看懂別人的 code 的速度 上手別人專案的速度 一開始真的看不蓋懂哪邊是在寫什麼邏輯 後來慢慢熟悉後，就可以快速找到對應的 code 了解到 CI/CD 的重要性 對 git 更熟一些 當時是對 feature 開 branch ，然後 hostinger 上的 code 就是 master 偏向 git flow 的方式 社團 # 在開學前，潛水到成大電機的 FB 社團 結果剛好看到GDCS( Google Developer Student Club in NCKU ) 的推廣貼文 就去報名了 那時候以為要成為「核心成員」才能聽課 結果是「核心成員」是要教課的 開學才招募的「一般成員」才是聽課的 誤打誤撞大一就當上核心成員了 🥵 上學期 NCKU GDSC 的組別\n結果就變成核心成員在教 Flutter ( 當時剛好加入 Flutter 組 ) Flutter Tutorial 的 repository jason810496/FlutterToturial Dart Toturial for GDSC NCKU Dart 1 0 在學期初課程都還沒什麼壓力 感覺還有點閒 就額外加入其他組\nSolidity 讀書會 學習 Solidity 和 Ethereum 相關的知識 組長會分配每次的 loading ， 大家要看過所有的 loading ， 下次讀書會的時後會輪流分享討論 資安密碼學組 一開始是純密碼學 後來轉為偏實作的 CTF 但只有上過兩堂課就大家都進入期末週了 但是在期末各種 Deadline 轟炸下 就發現加太多組別了 完全忙不太過來 最後只有去在 Flutter 組 對其他組的組長很砲歉 😥 比賽 # NCPC # 應該是因為 APCS 組進來的關係，剛好跟兩個競程特選大佬 @ColtenOuO跟 @erichung1113 是同一個導師（人超好的奇業教授！）\n找我們去聊天的時候剛好聊到 ICPC 跟 NCPC 這兩個比賽 原本大學沒有想要打比賽，不過好像講一講就報名了 最後是 @erichung1113 跟打字超爆快的另一個特選大佬 @jerrykal 一隊\n( 最後在 NCPC 拿佳作，差幾名就可以去比 ICPC 了 )\nEOF CTF # @ColtenOuO某天突然問我要不要報 EOF CTF ， 說 @bacon-cy學姊找他一起報 要不要一起來玩 結果還缺一個隊友 （那時候我在 GDSC 密碼學資安組）剛好在裡面認識一個很強的學長 @三腳蛇 就順便拉他一起來比了 結果比賽第一天剛好騎車去嘉義阿里山 後來也沒解出聲下的題目 （ 我只會 web ， 但那次的 web 都沒什麼頭緒，也有點舊沒有碰 CTF 了 ）\n所以基本上沒有貢獻，跟隊友說抱歉 😢 HITCON CTF # 之前聊天的時候大二的 @Vincent550102 學長有把我拉到 NCKU CTF 的 DC 裡面不定時會揪團打 CTF 一年一次的 HITCON CTF 學長們當然不會錯過 結果看了第一題 web 題 （ 主要是從前端 js bypass ， 好像要送到後端的 content 要符合長度限制還有一些 byte 操作 ） 看了很久，測了很多方法，不過還是沒解讀出關鍵的 code ( 只能說對 js 的一些細節原生方法還不夠熟悉＠＠ ) 後來群內有其他大佬解出了！！！ 陸續也有其他大佬解出不少題 最後 NCKU CTF 全球第 37 名 (台灣第2; 共 95 國，1243 個隊伍參賽) 這場也是打水漂，沒有貢獻 🥲 學長們超強 Orz 只會 web 但遇到有難度的 web 又寫不出來，真的還缺蠻多經驗的 （ 最後的 Ranking ）\n課程 # 實作類 # 程式設計（一） 在教 C 的語法，作業題目有些有點毒瘤 考試會超過 100 分，對初學者來說有點難 不過教授人蠻好的，不到 60 分的都會開根號乘 10 程式設計（一）的 repository jason810496/CKJudge Programming Design 1 Exercises C 0 0 因為之前有 C 的經驗，所以作業都算還好 最後 100 分過 視窗程式設計 C# , OOP WindForm Unity 期末專案 課程前期 前期都在教 C# 的 WinForm 還有超基本的 OOP ，但是又沒有講到一些 OOP 的重點 （ 大概只有講到 constructor 、繼承 ，但是像 interface 或多型這種都沒有特別說到 ）\n助教的 Deadline 都壓很緊但是又改超級慢\u0026hellip; 課堂完成有 Bonus 分，但基本上不太可能在下課前完成 對 Mac M1 的用戶來說，一定要先裝好 Window 的 VM 才有辦法完成 WinForm 的作業 期中考是上機考，不過也是刻 WinForm 跟作業差不多 視窗程式設計的 repository jason810496/Window-Programming C# 2 0 課程中期\n開始教 Unity ，由助教教 Unity 3D 做遊戲 沒有跟著助教是真的不知道怎麼操作 然後教大概 3 週後，就要做一個包含蠻多 features 的遊戲 Legend of Viking jason810496/Legend-of-Viking My Unity Game deploy on Github page HTML 0 0 （ Unity 大作業 repository ）\nGithub Page Demo\n（ 後來有把遊戲 compile 成 WebGL 部署在 Github Page ）\n課程後期\n最後要做一個期末專案 主題不限，可以是： WinForm 工具、Unity 多人遊戲、只要是 C# 寫的應該都可以\n( 說不定 Asp.Net 也可以 XD )\n最後我做的小專案是做 Live Share IDE 一個可以即時共享資訊的 IDE Tech stack：\nWinForm Python 原生 socket 只用這些東西自幹出來的 ouo ( 那時候不知道為什麽很喜歡硬幹，不喜歡用現成的 packages ) 成果：\nLive Share IDE 的 repository jason810496/Live-Share-IDE A Live-Share IDE written in C#. With directory tree , syntax high-lighting , chat room \u0026hellip; etc C# 2 0 ( 可以看成跟 VSCode 介面很像，不過本身就有支援 chatroom 的 IDE )\n再決定好主題後其實都沒有動工 是在 Demo 前一天花一天半幹出來的 這門課對我應該就是在訓練「趕 Deadline 」\n學科類 # 普物\n微積分\n數位電路導論\n總結 # 在最低限度維持學科的情況，所有科目都幸運的 Pass 了！\n但成績真的不太好看\n跟程設有關的科目\n因為高三接作業的關係，在實作一些比較複雜的作業就不會排斥\n也不用特別複習\n在接案和用 HSPC 系統的過程中比較有收穫\n了解為什麼要有 框架 、 CI/CD 、 DevOps 這些技術\n但是在整體時間分配應該還要再調整一下\n一次參加太多活動最後真的都會忙不過來\n","date":"2023-06-23","externalUrl":null,"permalink":"/zh-tw/note/csie-freshman-first-semester/","section":"Note","summary":"大一上到底做了什麼","title":"成大資工大一上紀錄","type":"note"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-tw/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-tw/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/zh-tw/topics/","section":"Topics","summary":"","title":"Topics","type":"topics"}]